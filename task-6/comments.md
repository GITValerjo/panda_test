В данном задании тоже происходит утечка памяти из-за циклической ссылки: $a (через $a->{cnt})
Циклическая ссылка мешает сборщику мусора Perl освободить память, так как он использует подсчет ссылок для управления памятью. В результате память, выделенная для $a, никогда не освобождается, и программа будет потреблять все больше памяти, пока не закончится доступная память.

Решение видится аналогичным предыдущему заданию:
use Scalar::Util qw(weaken);

while (1) {
    my $a = {};
    $a->{func} = sub {
        $a->{cnt}++;
    };
    weaken($a);  # Ослабляем ссылку на $a
}

D:\panda_test\task-6>perl weaken_ref_save_memory2.pl
Вывод в терминал примера:
Проверка на утечку памяти:
Cycle (1):
                          $A->{'func'} => \&B
                        $B variable $a => \$C
                                   $$C => \%A

Проверка после ослабления ссылки:
