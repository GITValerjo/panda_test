Вывод в консоли:
$ ./variable_types_comparison.pl

=== Start of script ===

=== Using my ===
A=1
A=1
A=1
A=1
A=1
A=1
A=1
A=1
A=1
A=1

=== Using our ===
A=1
A=2
A=3
A=4
A=5
A=6
A=7
A=8
A=9
A=10

=== Using local ===
A=1
A=1
A=1
A=1
A=1
A=1
A=1
A=1
A=1
A=1
Finally A=5

=== Using state ===
A=1
A=2
A=3
A=4
A=5
A=6
A=7
A=8
A=9
A=10

=== End of script ===

Итого:

my:
Создает лексическую переменную с областью видимости, ограниченной текущим блоком.
Переменная создается заново при каждом вызове функции.
Значение не сохраняется между вызовами.

our:
Создает глобальную переменную, доступную во всем пакете.
Значение сохраняется между вызовами функции.
Общая для всех частей программы, использующих этот пакет.

local:
Временно изменяет значение глобальной переменной в текущем блоке.
После выхода из блока значение переменной восстанавливается.
Не создает новую переменную.

state:
Создает лексическую переменную, которая сохраняет свое значение между вызовами функции.
Инициализируется только один раз при первом вызове.

my $var if 0:
Устаревшая конструкция, больше не поддерживается в современных версиях Perl.
Если условие ложно (if 0), переменная не объявляется, что может привести к неожиданному использованию глобальной переменной.
 #!/usr/bin/perl
 use strict;
 use warnings;
 use feature 'say';

 say "=== Using my \$var if 0 ===";

 sub func_my_if_0 {
     my $var if 0;  # Переменная не объявляется из-за условия if 0
     $var++;
     say "A=$var";
 }
 func_my_if_0() for 1..10;


 This is perl 5, version 40, subversion 2 (v5.40.2) - этот финт не уже поддерживает

 https://www.jdoodle.com/execute-perl-online на версии 5.26.2 вывел в консоль

 === Using my $var if 0 ===
 A=1
 A=2
 A=3
 A=4
 A=5
 A=6
 A=7
 A=8
 A=9
 A=10
 